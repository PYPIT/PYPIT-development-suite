#!/usr/bin/env python
#
# See top-level LICENSE.rst file for Copyright information
#
# -*- coding: utf-8 -*-

"""
This script runs the PYPIT development suite of tests
"""

from __future__ import absolute_import, division, print_function

import argparse
import os
import sys
import glob


def main():

    all_tests = ['kast', 'lris', 'isis', 'hires',  # Instuments
                 'keck', 'shane', 'wht']  # Observatories
    hlpstr = ", ".join(all_tests)
    import subprocess
    import warnings
    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    parser.add_argument('tests', type=str, default=None, help='Tests to run.  Options include: all, {0:s}'.format(hlpstr))
    parser.add_argument('-outputdir', type=str, help="Output folder.  Default is ./REDUX_OUT")
    parser.add_argument('-setup', type=str, help="Single out a setup to run")

    pargs = parser.parse_args()

    # Grab a list of all instruments
    raw_data = 'RAW_DATA/'
    calib_data = 'PYPIT_CALIBS'

    walk = os.walk(raw_data)
    all_instruments = next(walk)[1]

    # Setup
    if pargs.tests == 'all':
        instruments = all_instruments
    else:
        if pargs.tests == 'kast':
            instruments = [item for item in all_instruments if 'Kast' in item]
        elif pargs.tests == 'lris':
            instruments = [item for item in all_instruments if 'LRIS' in item]
        elif pargs.tests == 'isis':
            instruments = [item for item in all_instruments if 'ISIS_blue' in item]
        elif pargs.tests == 'hires':
            instruments = [item for item in all_instruments if 'Keck_HIRES' in item]
        elif pargs.tests == 'keck':
            instruments = [item for item in all_instruments if 'Keck' in item]
        elif pargs.tests == 'shane':
            instruments = [item for item in all_instruments if 'Shane' in item]
        elif pargs.tests == 'wht':
            instruments = [item for item in all_instruments if 'WHT' in item]
        else:
            print("\x1B[" + "1;31m" + "\nERROR - " + "\x1B[" + "0m" +
                  "Not prepared for this test: {0:s}\n\n".format(pargs.tests) +
                  "Please select from one of the following options:\n" +
                  "all, {0:s}\n".format(hlpstr), file=sys.stderr)
            sys.exit()

    if pargs.outputdir is None:
        outputdir = 'REDUX_OUT/'
    else:
        outputdir = pargs.outputdir
    if not os.path.exists(outputdir):
        os.mkdir(outputdir)
    else:
        print("Output directory exists.")
    # Run
    pwd = os.getcwd()

    # Loop on instruments
    npass, ntest = 0, 0
    for instr in instruments:
        #if instr in ['kast_blue','Kast_red']:  # For testing
        #if instr in ['lris_blue']: # Testing
        #    continue
        # Setups
        setups = next(os.walk(raw_data+'/'+instr))[1]
        for setup in setups:
            if pargs.setup is not None:
                if setup != pargs.setup:
                    continue
            # Generate folder as need be
            idir = outputdir+'/'+instr
            if not os.path.exists(idir):
                os.makedirs(idir)
            wdir = os.path.join(outputdir, instr, setup)
            if not os.path.exists(wdir):
                os.makedirs(wdir)
            # rawdata
            rawdir = os.path.join(pwd, 'RAW_DATA', instr, setup)+'/'
            # Run setup?
            if instr.lower() in ['shane_kast_blue', 'keck_lris_red']:
                ntest += 1
                outfile = instr.lower()+'_'+setup.lower()
                logfile = wdir+'/'+instr.lower()+'_'+setup.lower()+'.log2'
                with open(logfile, 'w') as f:
                    retval = subprocess.call(['pypit_setup', rawdir, instr.lower(), '-c'], stderr=f, cwd=wdir)
                wdir = wdir+'/'+instr.lower()+'_setup_A'
                print('Finished running pypit on {:s} --- '.format(outfile), file=sys.stderr, end='')
                # Run pypit on setup_A.pypit
                pyp_file = glob.glob(wdir+'/*setup_A.pypit')
                if len(pyp_file) != 1:
                    import pdb as debugger
                    debugger.set_trace()
                    raise ValueError("Incorrect .pypit files")
                else:
                    pyp_file = pyp_file[0]
                    islsh = pyp_file.rfind('/')
                    pyp_file = pyp_file[islsh+1:]
                    if retval == 0:
                        print("\x1B[" + "1;32m" + "PASSED" + "\x1B[" + "0m", file=sys.stderr)
                        npass += 1
                subprocess.call(['tail', '-2', logfile])
                print("\n", file=sys.stderr)
            else: # Use pre-made PYPIT file
                redfile = 'pypit_files/'+instr.lower()+'_'+setup.lower()+'.pypit'
                if not os.path.exists(redfile):
                    warnings.warn('No redux file: {:s}'.format(redfile))
                    warnings.warn('Not testing..')
                    continue
                # Edit data directory
                with open(redfile, 'r') as infile:
                    lines = infile.readlines()
                for kk, iline in enumerate(lines):
                    if 'data read' in iline:
                        dpth = lines[kk+1]
                        i0 = dpth.rfind('/')
                        newdpth = ' '+pwd+'/'+raw_data+'/'+instr+'/'+setup+dpth[i0:]
                        lines[kk+1] = newdpth
                    elif 'reduce flatfield useframe' in iline:
                        cpth = lines[kk]
                        i0 = cpth.rfind('/')
                        newcpth = pwd+'/CALIBS/'+cpth[i0:]
                        lines[kk] = 'reduce flatfield useframe '+newcpth
                # Write to outputdir
                outfile = wdir+'/'+instr.lower()+'_'+setup.lower()+'.pypit'
                pyp_file = instr.lower()+'_'+setup.lower()+'.pypit'
                with open(outfile, 'w') as ofile:
                    for iline in lines:
                        ofile.writelines(iline)

            # Run pypit
            ntest += 1
            logfile = wdir+'/'+instr.lower()+'_'+setup.lower()+'.log3'
            print('Running pypit on {:s} --- '.format(pyp_file), file=sys.stderr, end='')
            with open(logfile, 'w') as f:
                retval = subprocess.call(['run_pypit', pyp_file, '--devtest', '-v 2'], stderr=f, cwd=wdir)#, shell=True)
                if retval == 0:
                    print("\x1B[" + "1;32m" + "PASSED" + "\x1B[" + "0m", file=sys.stderr)
                    npass += 1
                else:
                    print("\x1B[" + "1;31m" + "FAILED" + "\x1B[" + "0m", file=sys.stderr)
                subprocess.call(['tail', '-2', logfile])
                print("\n", file=sys.stderr)
            # Test master frame running
            if instr in ['keck_lris_red']:
                ntest += 1
                logfile = wdir+'/'+instr.lower()+'_'+setup.lower()+'.log4'
                print('Running pypit with master frames on {:s} --- '.format(pyp_file), file=sys.stderr, end='')
                with open(logfile, 'w') as f:
                    retval = subprocess.call(['run_pypit', pyp_file, '--devtest', '-m', '-v 2'], stderr=f, cwd=wdir)#, shell=True)
                    if retval == 0:
                        print("\x1B[" + "1;32m" + "PASSED" + "\x1B[" + "0m", file=sys.stderr)
                        npass += 1
                    else:
                        print("\x1B[" + "1;31m" + "FAILED" + "\x1B[" + "0m", file=sys.stderr)
                    subprocess.call(['tail', '-2', logfile])
                    print("\n", file=sys.stderr)
    if npass == ntest:
        print("\n" + "\x1B[" + "1;32m" +
              "--- PYPIT DEVELOPMENT SUITE PASSED {0:d}/{1:d} TESTS ---".format(npass, ntest) +
              "\x1B[" + "0m" + "\r", file=sys.stderr)
    else:
        print("\n" + "\x1B[" + "1;31m" +
              "--- PYPIT DEVELOPMENT SUITE FAILED {0:d}/{1:d} TESTS ---".format(ntest-npass, ntest) +
              "\x1B[" + "0m" + "\r", file=sys.stderr)

if __name__ == '__main__':
    # Check for pypit executable
    if not any(os.access(os.path.join(
            path, 'run_pypit'), os.X_OK) for path in os.environ["PATH"].split(os.pathsep)):
        raise RuntimeError("You need to install run_pypit in your PATH")
    # Check for arclines (now a dependency for these tests)
    try:
        import arclines
    except ImportError:
        print("\n" + "\x1B[" + "1;31m" +
              "--- PYPIT DEVELOPMENT SUITE FAILED ---"+ "\x1B[" + "0m" + "\r", file=sys.stderr)
        raise RuntimeError("You need to install the arclines package")
    # Giddy up
    main()


