#!/usr/bin/env python
#
# See top-level LICENSE.rst file for Copyright information
#
# -*- coding: utf-8 -*-

"""
This script runs the PYPIT development suite of tests
"""

from __future__ import absolute_import, division, print_function

import argparse
import sys, os
import pdb
import glob

def main():

    import subprocess
    import warnings
    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    parser.add_argument('tests', type=str, default=None, help='Tests to run.  Options are: all, kast, lris, isis')
    parser.add_argument('-outputdir', type=str, help="Output folder.  Default is ./REDUX_OUT")
    parser.add_argument('-setup', type=str, help="Single out a setup to run")

    pargs = parser.parse_args()

    all_tests = ['kast', 'lris', 'isis']

    # Grab a list of all instruments
    raw_data = 'RAW_DATA/'
    calib_data = 'PYPIT_CALIBS'

    walk = os.walk(raw_data)
    all_instruments = next(walk)[1]

    # Setup
    if pargs.tests == 'all':
        instruments = all_instruments
    else:
        if pargs.tests == 'kast':
            instruments = [item for item in all_instruments if 'Kast' in item]
        elif pargs.tests == 'lris':
            instruments = [item for item in all_instruments if 'LRIS' in item]
        elif pargs.tests == 'isis':
            instruments = [item for item in all_instruments if 'ISIS_blue' in item]
        else:
            raise IOError("Not prepared for this test: {:s}".format(pargs.tests))

    if pargs.outputdir is None:
        outputdir = 'REDUX_OUT/'
    else:
        outputdir = pargs.outputdir
    if not os.path.exists(outputdir):
        os.mkdir(outputdir)
    else:
        print("Output directory exists.")
    # Run
    pwd = os.getcwd()

    # Loop on instruments
    for instr in instruments:
        #if instr in ['kast_blue','Kast_red']:  # For testing
        #    continue
        # Setups
        setups = next(os.walk(raw_data+'/'+instr))[1]
        for setup in setups:
            if pargs.setup is not None:
                if setup != pargs.setup:
                    continue
            # Generate folder as need be
            idir = outputdir+'/'+instr
            if not os.path.exists(idir):
                os.makedirs(idir)
            wdir = os.path.join(outputdir,instr,setup)
            if not os.path.exists(wdir):
                os.makedirs(wdir)
            # rawdata
            rawdir = os.path.join(pwd,'RAW_DATA',instr,setup)+'/'
            # Run setup?
            if instr.lower() in ['kast_blue']:
                logfile = wdir+'/'+instr.lower()+'_'+setup.lower()+'.log2'
                with open(logfile,'w') as f:
                    subprocess.call(['pypit_setup', rawdir, instr.lower()], stderr=f, cwd=wdir)#, shell=True)
                #print('Done running pypit on {:s} --- '.format(outfile))
                subprocess.call(['tail', logfile])
                # Run pypit on setup_A.pypit
                pyp_file = glob.glob(wdir+'/*setup_A.pypit')
                if len(pyp_file) != 1:
                    raise ValueError("Incorrect .pypit files")
                else:
                    pyp_file = pyp_file[0]
                    islsh = pyp_file.rfind('/')
                    pyp_file = pyp_file[islsh+1:]
            else:
                # Look for PYPIT file
                redfile = 'pypit_files/'+instr.lower()+'_'+setup.lower()+'.pypit'
                if not os.path.exists(redfile):
                    warnings.warn('No redux file: {:s}'.format(redfile))
                    warnings.warn('Not testing..')
                    continue
                # Edit data directory
                with open(redfile, 'r') as infile:
                    lines = infile.readlines()
                for kk,iline in enumerate(lines):
                    if 'data read' in iline:
                        dpth = lines[kk+1]
                        i0 = dpth.rfind('/')
                        newdpth = ' '+pwd+'/'+raw_data+'/'+instr+'/'+setup+dpth[i0:]
                        lines[kk+1] = newdpth
                    elif 'reduce flatfield useframe' in iline:
                        cpth = lines[kk]
                        i0 = cpth.rfind('/')
                        newcpth = pwd+'/CALIBS/'+cpth[i0:]
                        lines[kk] = 'reduce flatfield useframe '+newcpth
                # Write to outputdir
                outfile = wdir+'/'+instr.lower()+'_'+setup.lower()+'.pypit'
                pyp_file = instr.lower()+'_'+setup.lower()+'.pypit'
                with open(outfile, 'w') as ofile:
                    for iline in lines:
                        ofile.writelines(iline)

            # Run pypit
            logfile = wdir+'/'+instr.lower()+'_'+setup.lower()+'.log3'
            print('Running pypit on {:s} --- '.format(pyp_file))
            with open(logfile,'w') as f:
                subprocess.call(['run_pypit', pyp_file, '-v 2'], stderr=f, cwd=wdir)#, shell=True)


if __name__ == '__main__':
    # Check for pypit executable
    if not any(os.access(os.path.join(
            path, 'run_pypit'), os.X_OK) for path in os.environ["PATH"].split(os.pathsep)):
        raise RuntimeError("You need to install run_pypit in your PATH")
    # Giddy up
    main()


