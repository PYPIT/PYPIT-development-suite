#!/usr/bin/env python3
#
# See top-level LICENSE.rst file for Copyright information
#
# -*- coding: utf-8 -*-

"""
This script runs the PypeIt development suite of tests
"""

from __future__ import absolute_import, division, print_function

import sys
import os

import numpy as np


def parser(options=None):
    import argparse

    all_tests = ['kast', 'lris', 'deimos', 'nires',  # Instruments
                 'keck'] # Observatories
#    all_tests = ['kast', 'lris', 'isis', 'hires', 'deimos',  # Instruments
#                 'keck', 'shane', 'wht']  # Observatories

    hlpstr = ", ".join(all_tests)

    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    parser.add_argument('tests', type=str, default=None,
                        help='Tests to run.  Options include: all, {0:s}'.format(hlpstr))
    parser.add_argument('-outputdir', type=str, help="Output folder.  Default is ./REDUX_OUT")
    parser.add_argument('-setup', type=str, help="Single out a setup to run")

    return parser.parse_args() if options is None else parser.parse_args(options), hlpstr

def main():
#    import oslris
    import glob
    import subprocess
    import warnings

    pargs, hlpstr = parser()

    # TODO: Once we're satisfied than an instrument passes, add it to
    # this list!  It must pass for every directory that includes these
    # strings and all the sub-directory setups within!
    valid_instruments = ['Kast', 'DEIMOS', 'LRIS', 'NIRES', 'GNIRS', 'XSHOOTER']

    # Grab a list of all instruments
    dev_path = os.getenv('PYPEIT_DEV')
    raw_data = os.path.join(dev_path, 'RAW_DATA')

    if not os.path.isdir(raw_data):
        raise ValueError('No directory: {0}'.format(raw_data))

    #calib_data = 'PYPEIT_CALIBS'

    walk = os.walk(raw_data)
    all_instruments = next(walk)[1]

    # Setup
    if pargs.tests == 'all':
        instruments = [item for item in all_instruments for inst in valid_instruments 
                            if inst.lower() in item.lower()]
        invalid_selection = []
    else:
        instruments = [item for item in all_instruments if pargs.tests.lower() in item.lower()]
        invalid_selection = [item for item in instruments if not np.any([inst.lower()
                                    in item.lower() for inst in valid_instruments]) ]
    # Check that instruments is not blank
    if len(instruments) == 0:
        print("\x1B[" + "1;31m" + "\nERROR - " + "\x1B[" + "0m" +
              "Invalid test selected: {0:s}\n\n".format(pargs.tests) +
              "Consult the help (pypeit_test -h) or select one of the " +
              "available RAW_DATA directories: {0}".format(all_instruments))
        return 1

    if len(invalid_selection) > 0:
        print("\x1B[" + "1;33m" + "\nWARNING - " + "\x1B[" + "0m" +
              "The following tests have not been validated and may not pass: {0}\n\n".format(
              invalid_selection))

    outputdir = 'REDUX_OUT' if pargs.outputdir is None else pargs.outputdir
    if not os.path.exists(outputdir):
        os.mkdir(outputdir)
    outputdir = os.path.abspath(outputdir)

    # Loop on instruments
    npass, ntest = 0, 0

    # Do them in order Shane, LRIS, DEIMOS, since DEIMOS takes the
    # longest. To do this we sort and reverse, and then apply the kludge below
    instruments.sort(reverse=True)
    if 'Keck_DEIMOS' in instruments and len(instruments) > 2:
        instruments[-2], instruments[-1]=instruments[-1],instruments[-2]

    # Report
    print('Running tests on the following instruments:')
    for instr in instruments:
        print('    {0}'.format(instr))
    print('')

    for instr in instruments:
        # Setups
        setups = next(os.walk(os.path.join(raw_data, instr)))[1]

#        JFH Not sure who added this line but obviously it was a hack to speed things up.
#        if 'blue' not in instr:
#            continue

        # Report
        print('The following setups have been found for {0}:'.format(instr))
        for setup in setups:
            print('    {0}'.format(setup))
        print('')

        for setup in setups:

            if pargs.setup is not None and setup != pargs.setup:
                print('Setup {0} not selected for testing.   Continuing...'.format(setup))
                print('')
                continue

            # Generate folder as need be
            idir = os.path.join(outputdir, instr)
            if not os.path.exists(idir):
                os.makedirs(idir)
            wdir = os.path.join(idir, setup)
            if not os.path.exists(wdir):
                os.makedirs(wdir)

            # rawdata
            rawdir = os.path.join(raw_data, instr, setup)

            # Report
            print('Directories:')
            print('         Raw data: {0}'.format(rawdir))
            print('    PypeIt output: {0}'.format(wdir))
            print('')

            # Run setup?
            passed = True

            # TODO: By default search for the appropriate pypeit file
            # and run pypeit_setup if it doesn't exist
            
            # TODO: Include option that forces the tests to run
            # pypeit_setup

            outfile_root = instr.lower()+'_'+setup.lower()

            if instr.lower() in ['shane_kast_blue']:
                # Use pypeit_setup to get the pypeit file for Shane Kast Blue
                ntest += 1
                logfile = os.path.join(wdir, outfile_root+'.test.log')
                with open(logfile, 'w') as f:
                    command_line = ['pypeit_setup', '-r', rawdir, '-s', instr.lower(), '-c', '-o',
                                    '--output_path', wdir ]
                    print('Running command: {0}'.format(' '.join(command_line)))
                    retval = subprocess.call(command_line, stderr=f, cwd=wdir)

                wdir = os.path.join(wdir, instr.lower()+'_A')
                print('Finished running pypeit on {0} --- '.format(outfile_root),
                      file=sys.stderr, end='')

                # Run pypeit on _A.pypeit
                pyp_file = glob.glob(os.path.join(wdir, '*_A.pypeit'))
                if len(pyp_file) != 1:
                    print('Could not find expected pypeit file: {0}'.format(pyp_file))
                    print("\x1B[" + "1;31m" + "FAILED" + "\x1B[" + "0m", file=sys.stderr)
                    passed = False
                else:
                    pyp_file = os.path.split(pyp_file[0])[1]
                    if retval == 0:
                        print("\x1B[" + "1;32m" + "PASSED" + "\x1B[" + "0m", file=sys.stderr)
                        npass += 1
                subprocess.call(['tail', '-2', logfile])
                print("\n", file=sys.stderr)
            else:
                # Use pre-made PypeIt file
                pyp_file = os.path.join('pypeit_files', outfile_root+'.pypeit')

                if not os.path.exists(pyp_file):
                    warnings.warn('PypeIt file {0} does not exist.  Continuing...'.format(pyp_file))
                    continue

                # Read the pypeit file
                with open(pyp_file, 'r') as infile:
                    lines = infile.readlines()

                # Replace the default path with the local one
                for kk, iline in enumerate(lines):
                    if 'data read' in iline:
                        dpth = lines[kk+1]
                        newdpth = ' path ' if 'path' in dpth else ' '
                        i0 = dpth.rfind('/')
                        if setup.strip('/') == dpth[i0:].strip('/\n'):
                            # TODO: Test is for WHT path issue...
                            newdpth += os.path.join(raw_data, instr, setup)+'\n'
                        else:
                            newdpth += os.path.join(raw_data, instr, setup+dpth[i0:])
                        lines[kk+1] = newdpth
                    elif 'flatfield' in iline and 'frame' in lines[kk+1]:
                        newcpth = os.path.join(dev_path, 'CALIBS', os.path.split(lines[kk+1])[1])
                        lines[kk+1] = '        frame = {0}'.format(newcpth)

                # Write to outputdir
                pyp_file = outfile_root+'.pypeit'
                with open(os.path.join(wdir, pyp_file), 'w') as ofile:
                    ofile.writelines(lines)
             
            # Run pypeit
            if passed:
                ntest += 1
                logfile = os.path.join(wdir, outfile_root+'.test.log')
                print('Running pypeit on {:s} --- '.format(pyp_file), file=sys.stderr, end='')
                with open(logfile, 'w') as f:
                    print('Directory: {0}'.format(wdir))
                    command_line = [ 'run_pypeit', pyp_file, '-o' ]
                    print('Command line: {0}'.format(' '.join(command_line)))
                    retval = subprocess.call(command_line, stderr=f, cwd=wdir)
                    npass = report_test(retval, npass)
                    subprocess.call(['tail', '-2', logfile])
                    print("\n", file=sys.stderr)

                # Test master frame running
                if instr in ['keck_lris_red']:
                    ntest += 1
                    print('Running pypeit with master frames on {0} --- '.format(pyp_file),
                          file=sys.stderr, end='')
                    with open(logfile, 'w') as f:
                        print('Directory: {0}'.format(wdir))
                        command_line = [ 'run_pypeit', pyp_file, '-m', '-o' ]
                        print('Command line: {0}'.format(' '.join(command_line)))
                        retval = subprocess.call(command_line, stderr=f, cwd=wdir)
                        npass = report_test(retval, npass)
                        subprocess.call(['tail', '-2', logfile])
                        print("\n", file=sys.stderr)
            else:
                print("Couldn't run test for {0:s}".format(instr.lower()))

    if npass == ntest:
        print("\n" + "\x1B[" + "1;32m" +
              "--- PYPEIT DEVELOPMENT SUITE PASSED {0:d}/{1:d} TESTS ---".format(npass, ntest) +
              "\x1B[" + "0m" + "\r", file=sys.stderr)
    else:
        print("\n" + "\x1B[" + "1;31m" +
              "--- PYPEIT DEVELOPMENT SUITE FAILED {0:d}/{1:d} TESTS ---".format(ntest-npass,
              ntest) + "\x1B[" + "0m" + "\r", file=sys.stderr)

def report_test(retval, npass):
    if retval == 0:
        print("\x1B[" + "1;32m" + "PASSED" + "\x1B[" + "0m", file=sys.stderr)
        return npass + 1
    print("\x1B[" + "1;31m" + "FAILED" + "\x1B[" + "0m", file=sys.stderr)
    return npass

if __name__ == '__main__':
    # Check for pypeit executable
    if not any([os.access(os.path.join(path, 'run_pypeit'), os.X_OK)
                for path in os.environ["PATH"].split(os.pathsep)]):
        raise RuntimeError("You need to install run_pypeit in your PATH")
    # Giddy up
    main()


