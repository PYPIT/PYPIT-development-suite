#!/usr/bin/env python
#
# See top-level LICENSE.rst file for Copyright information
#
# -*- coding: utf-8 -*-

"""
This script runs the PypeIt development suite of tests
"""

from __future__ import absolute_import, division, print_function


def parser(options=None):
    import argparse

    all_tests = ['kast', 'lris', 'deimos',  # Instruments
                 'keck', 'shane']  # Observatories
#    all_tests = ['kast', 'lris', 'isis', 'hires', 'deimos',  # Instruments
#                 'keck', 'shane', 'wht']  # Observatories

    hlpstr = ", ".join(all_tests)

    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    parser.add_argument('tests', type=str, default=None,
                        help='Tests to run.  Options include: all, {0:s}'.format(hlpstr))
    parser.add_argument('-outputdir', type=str, help="Output folder.  Default is ./REDUX_OUT")
    parser.add_argument('-setup', type=str, help="Single out a setup to run")

    return parser.parse_args() if options is None else parser.parse_args(options), hlpstr


def main():
    import os
    import sys
    import glob
    import subprocess
    import warnings
    import pdb

    pargs, hlpstr = parser()

    # Grab a list of all instruments
    raw_data = os.getenv('PYPEIT_DEV') 
    #calib_data = 'PYPEIT_CALIBS'

    walk = os.walk(raw_data)
    all_instruments = next(walk)[1]

    valid_instruments = ['Kast','DEIMOS','LRIS']
    # Setup
    if pargs.tests == 'all':
        instruments = [item for item in all_instruments for inst in valid_instruments if inst in item]
    else:
        if pargs.tests == 'kast':
            instruments = [item for item in all_instruments if 'Kast' in item]
        elif pargs.tests == 'deimos':
            instruments = [item for item in all_instruments if 'DEIMOS' in item]
        elif pargs.tests == 'lris':
            instruments = [item for item in all_instruments if 'LRIS' in item]
        elif pargs.tests == 'keck':
            instruments = [item for item in all_instruments if 'Keck' in item]
        elif pargs.tests == 'shane':
            instruments = [item for item in all_instruments if 'Shane' in item]
#        elif pargs.tests == 'wht':
#            instruments = [item for item in all_instruments if 'WHT' in item]
#        elif pargs.tests == 'isis':
#            instruments = [item for item in all_instruments if 'ISIS' in item]
#        elif pargs.tests == 'hires':
#            instruments = [item for item in all_instruments if 'HIRES' in item]
        else:
            print("\x1B[" + "1;31m" + "\nERROR - " + "\x1B[" + "0m" +
                  "Not prepared for this test: {0:s}\n\n".format(pargs.tests) +
                  "Please select from one of the following options:\n" +
                  "all, {0:s}\n".format(hlpstr), file=sys.stderr)
            sys.exit()
    # Check that instruments is not blank
    if pargs.tests == 'deimos':
        if len(instruments) == 0:
            print("\x1B[" + "1;31m" + "\nERROR - " + "\x1B[" + "0m" +
                  "Not prepared for DEIMOS test.  Odds are you need to download the RAW_DATA")
            sys.exit()

    if pargs.outputdir is None:
        outputdir = 'REDUX_OUT/'
    else:
        outputdir = pargs.outputdir
    if not os.path.exists(outputdir):
        os.mkdir(outputdir)
    else:
        print("Output directory exists.")
    # Run
    pwd = os.getcwd()

    # Loop on instruments
    npass, ntest = 0, 0

    # Do them in order Shane, LRIS, DEIMOS, since DEIMOS takes the longest. To do this we sort and reverse
    instruments.sort(reverse=True)

    for instr in instruments:
        #if instr in ['kast_blue','Kast_red']:  # For testing
        # TESTING!!
        #if instr.lower() in ['keck_lris_blue']: # Testing
        #    continue
        # Setups
        setups = next(os.walk(raw_data+'/'+instr))[1]
        for setup in setups:
            if pargs.setup is not None:
                if setup != pargs.setup:
                    continue
            # Generate folder as need be
            idir = outputdir+'/'+instr
            if not os.path.exists(idir):
                os.makedirs(id
            wdir = os.path.join(outputdir, instr, setup)
            if not os.path.exists(wdir):
                os.makedirs(wdir)
            # rawdata
            rawdir = os.path.join(pwd, 'RAW_DATA', instr, setup)+'/'
            # Run setup?
            passed = True
            # Use pre-made pypeit file for keck_lris_red until someone fixes pypeit_setup which is currently broken.
            if instr.lower() in ['shane_kast_blue']: #, 'keck_lris_red']:
                ntest += 1
                outfile = instr.lower()+'_'+setup.lower()
                logfile = wdir+'/'+instr.lower()+'_'+setup.lower()+'.log2'
                with open(logfile, 'w') as f:
                    retval = subprocess.call(['pypeit_setup', rawdir, instr.lower(), '-c', '-o'], stderr=f, cwd=wdir)
                wdir = os.path.join(wdir, instr.lower()+'_setup_A')
                print('Finished running pypeit on {:s} --- '.format(outfile), file=sys.stderr, end='')
                # Run pypeit on setup_A.pypeit
                pyp_file = glob.glob(os.path.join(wdir, '*setup_A.pypeit'))
                if len(pyp_file) != 1:
                    print("Couldn't find PypeIt file")
                    print("Incorrect .pypeit files")
                    print("\x1B[" + "1;31m" + "FAILED" + "\x1B[" + "0m", file=sys.stderr)
                    passed = False
                    #pdb.set_trace()
                    #raise ValueError("Incorrect .pypeit files")
                else:
                    pyp_file = pyp_file[0]
                    islsh = pyp_file.rfind('/')
                    pyp_file = pyp_file[islsh+1:]
                    if retval == 0:
                        print("\x1B[" + "1;32m" + "PASSED" + "\x1B[" + "0m", file=sys.stderr)
                        npass += 1
                subprocess.call(['tail', '-2', logfile])
                print("\n", file=sys.stderr)
            else: # Use pre-made PypeIt file
                redfile = 'pypeit_files/'+instr.lower()+'_'+setup.lower()+'.pypeit'
                if not os.path.exists(redfile):
                    warnings.warn('No redux file: {:s}'.format(redfile))
                    warnings.warn('Not testing..')
                    continue
                # Edit data directory
                with open(redfile, 'r') as infile:
                    lines = infile.readlines()
                for kk, iline in enumerate(lines):
                    if 'data read' in iline:
                        dpth = lines[kk+1]
                        if 'path' in dpth:
                            newdpth = ' path '
                        else:
                            newdpth = ' '
                        i0 = dpth.rfind('/')
                        if setup.strip('/') == dpth[i0:].strip('/\n'):
                            # TODO: Test is for WHT path issue...
                            newdpth += pwd+'/'+raw_data+'/'+instr+'/'+setup+'\n'
                        else:
                            newdpth += pwd+'/'+raw_data+'/'+instr+'/'+setup+dpth[i0:]
                        lines[kk+1] = newdpth
                    elif 'flatfield' in iline and 'frame' in lines[kk+1]:
                        cpth = lines[kk+1]
                        i0 = cpth.rfind('/')
                        newcpth = pwd+'/CALIBS/'+cpth[i0:]
                        lines[kk+1] = '        frame = {0}'.format(newcpth)
                # Write to outputdir
                outfile = wdir+'/'+instr.lower()+'_'+setup.lower()+'.pypeit'
                pyp_file = instr.lower()+'_'+setup.lower()+'.pypeit'
                with open(outfile, 'w') as ofile:
                    for iline in lines:
                        ofile.writelines(iline)

            # Run pypeit
            if passed:
                ntest += 1
                logfile = wdir+'/'+instr.lower()+'_'+setup.lower()+'.log3'
                print('Running pypeit on {:s} --- '.format(pyp_file), file=sys.stderr, end='')
                with open(logfile, 'w') as f:
                    print(wdir)
                    print('run_pypeit', pyp_file, '-o')
    #                retval = 0
    #                retval = subprocess.call(['run_pypeit', pyp_file, '--devtest', '-v 2','-d'], stderr=f, cwd=wdir)#, shell=True)
                    retval = subprocess.call(['run_pypeit', pyp_file, '-o'], stderr=f, cwd=wdir)#, shell=True)
                    if retval == 0:
                        print("\x1B[" + "1;32m" + "PASSED" + "\x1B[" + "0m", file=sys.stderr)
                        npass += 1
                    else:
                        print("\x1B[" + "1;31m" + "FAILED" + "\x1B[" + "0m", file=sys.stderr)
                    subprocess.call(['tail', '-2', logfile])
                    print("\n", file=sys.stderr)
                # Test master frame running
                if instr in ['keck_lris_red']:
                    ntest += 1
                    logfile = wdir+'/'+instr.lower()+'_'+setup.lower()+'.log4'
                    print('Running pypeit with master frames on {:s} --- '.format(pyp_file), file=sys.stderr, end='')
                    with open(logfile, 'w') as f:
    #                    print(wdir)
                        print('run_pypeit', pyp_file, '-m', '-o')
    #                    retval = 0
    #                    retval = subprocess.call(['run_pypeit', pyp_file, '--devtest', '-m', '-v 2','-d'], stderr=f, cwd=wdir)#, shell=True)
                        retval = subprocess.call(['run_pypeit', pyp_file, '-o', '-m'], stderr=f, cwd=wdir)#, shell=True)
                        if retval == 0:
                            print("\x1B[" + "1;32m" + "PASSED" + "\x1B[" + "0m", file=sys.stderr)
                            npass += 1
                        else:
                            print("\x1B[" + "1;31m" + "FAILED" + "\x1B[" + "0m", file=sys.stderr)
                        subprocess.call(['tail', '-2', logfile])
                        print("\n", file=sys.stderr)
            else:
                print("Couldn't run test for {0:s}".format(instr.lower()))
    if npass == ntest:
        print("\n" + "\x1B[" + "1;32m" +
              "--- PYPEIT DEVELOPMENT SUITE PASSED {0:d}/{1:d} TESTS ---".format(npass, ntest) +
              "\x1B[" + "0m" + "\r", file=sys.stderr)
    else:
        print("\n" + "\x1B[" + "1;31m" +
              "--- PYPEIT DEVELOPMENT SUITE FAILED {0:d}/{1:d} TESTS ---".format(ntest-npass, ntest) +
              "\x1B[" + "0m" + "\r", file=sys.stderr)


if __name__ == '__main__':
    import sys, os

    # Check for pypeit executable
    if not any(os.access(os.path.join(
            path, 'run_pypeit'), os.X_OK) for path in os.environ["PATH"].split(os.pathsep)):
        raise RuntimeError("You need to install run_pypeit in your PATH")
    # Giddy up
    main()


