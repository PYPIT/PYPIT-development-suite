#!/usr/bin/env python3
#
# See top-level LICENSE.rst file for Copyright information
#
# -*- coding: utf-8 -*-

"""
This script runs the PypeIt development suite of tests
"""

import sys
import os
import os.path
import glob
import subprocess
from queue import Queue, Empty
from threading import Thread
import random
import traceback
import time

from IPython import embed

import numpy as np

test_run_queue = Queue()
""":obj:`queue.Queue`: FIFO queue for test setups to be run."""

test_result_queue = Queue()
""":obj:`queue.Queue`: FIFO queue of completed test results in PypeItTestResult objects."""

run_dummy_tests = False
"""Whether to run dummy tests for testing purposes. TODO: Remove this and use external unit test frame work"""

def develop_setups():
    """
    Return the list of development setups.
    """
    return {'shane_kast_blue': ['452_3306_d57', '600_4310_d55', '830_3460_d46'],
            'shane_kast_red': ['600_7500_d55_ret', '600_7500_d57', '600_5000_d46', '1200_5000_d57'],
            'keck_deimos': ['600ZD_M_6500', '1200G_M_7750', '830G_LVM_8400', '830G_M_8100_26',
                            '830G_M_8500', '830G_L_8100'],
            'keck_kcwi': ['bh2_4200'],
            'keck_nires': ['NIRES'],
            'keck_nirspec': ['LOW_NIRSPEC-1'],
            'keck_mosfire': ['Y_long', 'J_multi', 'K_long'],
            'keck_lris_blue': ['multi_600_4000_d560', 'long_400_3400_d560', 'long_600_4000_d560',
                               'multi_300_5000_d680'],
            'keck_lris_blue_orig': ['long_600_4000_d500'],
            'keck_lris_red': ['long_600_7500_d560', 'multi_1200_9000_d680_1x2',
                              'multi_600_5000_d560', 'multi_1200_9000_d680',
                              'multi_400_8500_d560'],
            'keck_lris_red_orig': ['long_300_5000'],
            'vlt_xshooter': ['VIS_1x1', 'VIS_2x1', 'VIS_2x2', 'NIR'],
            'gemini_gnirs': ['32_SB_SXD', '10_LB_SXD'],
            'gemini_gmos': ['GS_HAM_R400_700', 'GS_HAM_R400_860'],
            'gemini_flamingos2': ['HK_HK', 'JH_JH'],
            'magellan_mage': ['1x1'],
            'magellan_fire': ['FIRE_Echelle', 'FIRE_Long'],
            'mdm_osmos': ['MDM4K'],
            'not_alfosc': ['grism4', 'grism19'],
            'p200_dbsp_blue': ['600_4000_d55'],
            'p200_dbsp_red': ['316_7500_d55'],
            'vlt_fors2': ['300I'],
            'lbt_luci': ['LUCI-I', 'LUCI-II']
            }


def supported_instruments():
    return ['kast', 'deimos', 'kcwi', 'nires', 'nirspec', 'mosfire', 'lris', 'xshooter', 'gnirs', 'gmos',
            'flamingos2', 'mage', 'fire', 'luci', 'mdm', 'alfosc', 'fors2', 'dbsp']


class PypeItTestResult(object):
    """Holds results from running a pypeit test and has methods for reporting on those results"""

    types = {'PYPEIT_SETUP':    "pypeit_setup",
             "PYPEIT":          "pypeit (without masters)",
             "PYPEIT_MASTERS":  "pypeit (with masters)",
             "SENSFUNC":        "pypeit_sensfunc",
             "FLUX_SETUP":      "pypeit_flux_setup",
             "FLUXING":         "pypeit_flux",
             "COADD1D":         "pypeit_coadd_1dspec",
             "COADD2D":         "pypeit_coadd_2dspec",
             "TELLFIT":         "pypeit_tellfit",
             "QL":              "pypeit_ql_mos",
             "UNKNOWN":         "Unknown"}

    def __init__(self, instr, setup, test_type, rdxdir):
        """
        Constructor

        Args:
            instr (str): Instrument of the test
            setup (str): Test setup of the test
            test_type (str): The type of test performed. This is one of the keys of the 'types' class member
                             variable.
            rdxdir (str): The output directory the test was run in.
        """

        self.instr = instr
        self.setup = setup
        self.type = test_type
        self.rdxdir = rdxdir

        self.passed = None
        """ bool: True if the test passed, False if the test failed, None if the test is in progress"""

        self.command_line = []
        """ :obj:`list` of :obj:`str`: The command and arguments that were run for the test."""

        self.error_msgs = []
        """ :obj:`list` of :obj:`str`: List of any error messages generated by the test."""

        self.logfile = None
        """ str: The log file for the test """

        self.pid = None
        """ int: The process id of the child process than ran the test"""

    def report(self):
        """Display a report on the test to stdout/stderr"""

        # Report
        print ("-----")
        print("Directories:")
        print(f"         Raw data: {raw_data_dir()}")
        print(f"    PypeIt output: {self.rdxdir}")
        print(f"          Logfile: {self.logfile}")
        print(f"       Process Id: {self.pid}")
        print("")

        print(f"Command: {' '.join(self.command_line)}", file=sys.stderr)

        if self.passed:
            result = "\x1B[" + "1;32m" + f"{self.type} --- PASSED" + "\x1B[" + "0m"
        else:
            result = "\x1B[" + "1;31m" + f"{self.type} --- FAILED" + "\x1B[" + "0m"

        print(f"Ran {self.types[self.type]} on {self.instr}/{self.setup} Result: {result}\n", file=sys.stderr)

        for msg in self.error_msgs:
            print(msg, file=sys.stderr)

        if self.logfile is not None:
            subprocess.call(['tail', '-3', self.logfile])

        print("\n", file=sys.stderr)

    def __str__(self):
        """Return a summary of the test and the status.

           Example: 'shane_kast_red/600_7500_d57 pypeit (without masters): Passed'
        """
        return f"{self.instr}/{self.setup} {self.types[self.type]}: " \
               f"{'In Progress' if self.passed is None else 'Passed' if self.passed else 'Failed'}"




def raw_data_dir():
    return os.path.join(os.environ['PYPEIT_DEV'], 'RAW_DATA')


def available_data():
    walk = os.walk(raw_data_dir())
    return next(walk)[1]


def get_logfile(rdxdir, instr, setup, ext):

    # Get a unique log file to prevent a test from overwriting the log from a previous test
    logfile = os.path.join(rdxdir, '{0}_{1}.{2}.log'.format(instr.lower(), setup.lower(), ext))
    log_num = 2
    while os.path.exists(logfile):
        logfile = os.path.join(rdxdir, '{0}_{1}.{2}.{3}.log'.format(instr.lower(), setup.lower(), ext, log_num))
        log_num += 1

    return logfile

def run_test(test_result, cwd):
    """Run a test in a child process.

    Args:
        test_result (:obj:`PypeItTestResult`): In/Out argument for the results of the test.
        cwd (str): The working directory to run the child process in.
    """

    # TODO: Remove dummy test and use an external test frame work like pytest to do this
    if run_dummy_tests:
        delay =  random.randint(5,10)
        print(f"Test {test_result}: Sleeping for {delay} seconds.")
        time.sleep(delay)
        test_result.passed=True
    else:
        with open(test_result.logfile, "w") as f:
            try:
                child = subprocess.Popen(test_result.command_line, stdout=f, stderr=f, cwd=cwd)
                print(f"Test {test_result}: Started with pid {child.pid}")
                test_result.pid = child.pid
                child.wait()
                test_result.passed = (child.returncode == 0)
            finally:
                # Kill the child if the parent script exits due to a SIGTERM or SIGINT (Ctrl+C)
                child.terminate()

def run_pypeit_setup(rawdir, rdxdir, instr, setup):
    """
    Run pypeit_setup.

    Returns:
        tuple: Returns the PypeItTestResult of the test, the pypeit_file and the new
        output test directory for subsequen tests in the test setup
    """
    result = PypeItTestResult(instr, setup, 'PYPEIT_SETUP', rdxdir)

    # Use pypeit_setup to get the pypeit file
    result.logfile = get_logfile(rdxdir, instr, setup, 'test')
    result.command_line = ['pypeit_setup', '-r', rawdir, '-s', instr, '-c all', '-o',
                           '--output_path', rdxdir]

    run_test(result, rdxdir)

    # Check for the pypeit file
    rdxdir = os.path.join(rdxdir, instr.lower()+'_A')
    pyp_file = glob.glob(os.path.join(rdxdir, '*_A.pypeit'))
    if len(pyp_file) != 1:
        result.error_msgs.append(f"Could not find expected pypeit file: {pyp_file}")
        result.passed = False
        return result, None, rdxdir

    pyp_file = os.path.split(pyp_file[0])[1]

    return result, pyp_file, rdxdir


def pypeit_file_name(instr, setup, std=False):
    base = '{0}_{1}'.format(instr.lower(), setup.lower())
    return '{0}_std.pypeit'.format(base) if std else '{0}.pypeit'.format(base)


def template_pypeit_file(dev_path, instr, setup, std=False):
    return os.path.join(dev_path, 'pypeit_files', pypeit_file_name(instr, setup, std=std))


def coadd2d_file_name(instr, setup):
    return '{0}_{1}.coadd2d'.format(instr.lower(), setup.lower())


def template_coadd2d_file(dev_path, instr, setup):
    return os.path.join(dev_path, 'coadd2d_files', coadd2d_file_name(instr, setup))


def fix_pypeit_file_directory(dev_path, raw_data, instr, setup, rdxdir, std=False):
    """
    Use template pypeit file to write the pypeit file relevant to the
    exising directory structure.

    Returns:
        str: The path to the corrected pypeit file.
    """
    # Read the pypeit file
    pyp_file = template_pypeit_file(dev_path, instr, setup, std=std)
    if not os.path.isfile(pyp_file):
        if std:
            return None
        raise FileNotFoundError('File does not exist: {0}'.format(pyp_file))
    with open(pyp_file, 'r') as infile:
        lines = infile.readlines()

    # Replace the default path with the local one
    for kk, iline in enumerate(lines):
        if 'data read' in iline:
            old_path = lines[kk+1].strip().split(' ')[1] if 'path' in lines[kk+1] \
                            else lines[kk+1].strip()
            subdir = ''
            newdpth = ' path ' if 'path' in lines[kk+1] else ' '
            newdpth += os.path.join(raw_data, instr, setup, subdir)
            newdpth += '\n'
            lines[kk+1] = newdpth
        elif 'flatfield' in iline and 'pixelflat_file' in lines[kk+1]:
            newcpth = os.path.join(dev_path, 'CALIBS', os.path.split(lines[kk+1])[1])
            lines[kk+1] = '        pixelflat_file = {0}'.format(newcpth)

    # Write the pypeit file
    pyp_file = os.path.join(rdxdir, pypeit_file_name(instr, setup, std=std))
    with open(pyp_file, 'w') as ofile:
        ofile.writelines(lines)
    return pyp_file


def run_pypeit(rdxdir, instr, setup, pyp_file, masters):
    """
    Run pypeit on the provided instrument and setup in the provided
    reduction directory.

    Returns:
        obj:`PypeItTestResult`: The result of the test.
    """
    result = PypeItTestResult(instr, setup, "PYPEIT_MASTERS" if masters else "PYPEIT", rdxdir)

    result.logfile = get_logfile(rdxdir, instr, setup, 'test')
    result.command_line = ['run_pypeit', pyp_file, '-o']
    if masters:
        result.command_line += ['-m']

    run_test(result, rdxdir)

    return result


def run_sensfunc(rdxdir, instr, setup, std_file, sens_file=None):
    result = PypeItTestResult(instr, setup, "SENSFUNC", rdxdir)

    if not os.path.isfile(std_file):
        result.error_msgs.append(f"File does not exist!: {std_file}")
        result.passed = False
        return result

    result.logfile = get_logfile(rdxdir, instr, setup, 'test_sens')
    result.command_line = ['pypeit_sensfunc', std_file]
    if sens_file is not None:
        result.command_line += ['-s', sens_file]

    run_test(result, rdxdir)

    return result

def run_flux_setup(rdxdir, instr, setup):
    """
    Test telluric correction with pisco GNIRS data
    """
    result = PypeItTestResult(instr, setup, "FLUX_SETUP", rdxdir)
    result.logfile = get_logfile(rdxdir, instr, setup, 'test_flux_setup')
    result.command_line = ['pypeit_flux_setup', os.path.join(rdxdir, 'Science')]

    run_test(result, rdxdir)

    return result

def run_flux_calib(dev_path, rdxdir, instr, setup):
    result = PypeItTestResult(instr, setup, "FLUXING", rdxdir)
    result.logfile = get_logfile(rdxdir, instr, setup, 'test_flux')
    flux_file = os.path.join(dev_path, 'fluxing_files',
                             '{0}_{1}.flux'.format(instr.lower(), setup.lower()))
    result.command_line = ['pypeit_flux_calib', flux_file]

    run_test(result, rdxdir)
    return result


def run_coadd1d(dev_path, rdxdir, instr, setup):
    result = PypeItTestResult(instr, setup, "COADD1D", rdxdir)
    result.logfile = get_logfile(rdxdir, instr, setup, 'test_1dcoadd')
    coadd_file = os.path.join(dev_path, 'coadd1d_files',
                              '{0}_{1}.coadd1d'.format(instr.lower(), setup.lower()))
    result.command_line = ['pypeit_coadd_1dspec', coadd_file]

    run_test(result, rdxdir)
    return result


def run_coadd2d(rdxdir, instr, setup, coadd_file=None, obj=None):
    result = PypeItTestResult(instr, setup, "COADD2D", rdxdir)
    if coadd_file is None and obj is None:
        result.error_msgs.append('Must provided coadd2d file or object name.')
        result.passed = False
        return result

    result.logfile = get_logfile(rdxdir, instr, setup, 'test_2dcoadd')
    result.command_line = ['pypeit_coadd_2dspec']
    result.command_line += ['--obj', obj] if coadd_file is None else ['--file', coadd_file]

    run_test(result, rdxdir)
    return result

def run_tellfit(rdxdir, instr, setup, coadd_file, redshift, objmodel):
    """
    Test telluric correction with pisco GNIRS data
    """
    result = PypeItTestResult(instr, setup, "TELLFIT", rdxdir)
    result.logfile = get_logfile(rdxdir, instr, setup, 'test_tellfit')
    result.command_line = ['pypeit_tellfit', os.path.join(rdxdir, coadd_file)]
    result.command_line += ['--redshift', '{:}'.format(redshift)]
    result.command_line += ['--objmodel', objmodel]

    run_test(result, rdxdir)
    return result


def run_ql(rawdir, rdxdir, instr, setup, files, mos=False):
    result = PypeItTestResult(instr, setup, "QL", rdxdir)
    qldir = os.path.join(rdxdir, 'QL')
    if not os.path.isdir(qldir):
        os.mkdir(qldir)
    result.logfile = get_logfile(qldir, instr, setup, 'test_ql')
    result.command_line = ['pypeit_ql_mos', instr] if mos else ['pypeit_ql_keck_nires']
    result.command_line += [rawdir] + files

    run_test(result, rdxdir)
    return result



def parser(options=None):
    import argparse

    dirs = available_data()
    all_tests = np.unique([ [d.split('_')[0], d.split('_')[1]] for d in dirs ])

    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter,
                                     description='Run pypeit tests on a set of instruments.  '
                                                 'Typical call for testing pypeit when developing '
                                                 'new code is `./pypeit_test develop`.  Execution '
                                                 'requires you to have a PYPEIT_DEV environmental '
                                                 'variable, pointing to the top-level directory '
                                                 'of the dev-suite repository (typically the '
                                                 'location of this script).  Raw data for testing '
                                                 'is expected to be at ${PYPEIT_DEV}/RAW_DATA.  '
                                                 'To run all tests for the supported instruments, '
                                                 'use \'develop\'.  To only run the basic '
                                                 'reductions, use \'reduce\'.  To only run the '
                                                 'tests that use the results of the reductions, '
                                                 'use \'afterburn\'.  To run all possible tests '
                                                 '(beware!), use \'all\'.')

    parser.add_argument('tests', type=str, default=None,
                        help='Instrument or test to run.  For instrument-specific tests, you '
                             'can provide the telescope or the spectrograph, but beware of '
                             'non-unique matches.  E.g. \'mage\' selects all the magellan '
                             'instruments, not just \'magellan_mage\'.  Options include: '
                             'develop, reduce, afterburn, all, ql, {0}'.format(', '.join(all_tests)))
    parser.add_argument('-o', '--outputdir', type=str, default='REDUX_OUT',
                        help='Output folder.')
    # TODO: Why is this an option?
    parser.add_argument('-i', '--instrument', type=str, help="Restrict to input instrument")
    parser.add_argument('-s', '--setup', type=str, help="Single out a setup to run")
    parser.add_argument('--debug', default=False, action='store_true',
                        help='Debug using only blue setups')
    parser.add_argument('-p', '--prep_only', default=False, action='store_true',
                        help='Only prepare to execute run_pypeit, but do not actually run it.')
    parser.add_argument('-m', '--masters', default=False, action='store_true',
                        help='run pypeit using any existing masters')
    parser.add_argument('-d', '--dummy', default=False, action='store_true',
                        help='Run dummy tests to test this test script.')
    parser.add_argument('-t', '--threads', default=1, type=int,
                        help='The number of test threads to run in parallel.')

    return parser.parse_args() if options is None else parser.parse_args(options)

def thread_target():
    """Thread target method for running tests."""
    try:
        while (True):
            test_setup = test_run_queue.get_nowait()
            try:
                for test_result in run_test_setup(test_setup):
                    test_result_queue.put(test_result)
            except Exception:
                # Create a test result to document that an exception ocurred running the test
                test_result = PypeItTestResult(test_setup[1],
                                               test_setup[2],
                                               "UNKNOWN",
                                               "Unknown")
                test_result.error_msgs.append(f"Exception in Test Setup {test_setup[1]}/{test_setup[2]}:")
                test_result.error_msgs.append(traceback.format_exc())
                test_result.passed = False
                test_result_queue.put(test_result)

            # Count the test as done. This needs to be done to allow the join() call in main to return when
            # all of the tests have been completed
            test_run_queue.task_done()

    except Empty as e:
        # Queue is empty, let the thread terminate
        pass

def main():


    pargs = parser()

    if pargs.threads <=0:
        raise ValueError("Number of threads must be >= 1")
    elif pargs.threads > 1:
        # Set the OMP_NUM_THREADS to 1 to prevent numpy multithreading from competing for resources
        # with the multiple processes started by this script
        os.environ['OMP_NUM_THREADS'] = '1'


    global run_dummy_tests
    if pargs.dummy:
        run_dummy_tests = True

    # TODO: Once we're satisfied that an instrument passes, add it to
    # this list and add a series of setups to the development set!  Runs
    # of PypeIt must pass for all setups in the development list.  See
    # `develop_setups`.

    dev_path = os.getenv('PYPEIT_DEV')
    raw_data = raw_data_dir()
    if not os.path.isdir(raw_data):
        raise NotADirectoryError('No directory: {0}'.format(raw_data))

    all_instruments = available_data()
    flg_after = False
    flg_ql = False

    # Development instruments (in returned dictonary keys) and setups
    devsetups = develop_setups()
    tests_that_only_use_dev_setups = ['develop', 'reduce', 'afterburn', 'ql']

    # Setup
    unsupported = []
    if pargs.tests == 'all':
        instruments = np.array([item for item in all_instruments
                                        for inst in supported_instruments()
                                            if inst.lower() in item.lower()])
    elif pargs.tests in tests_that_only_use_dev_setups:
        instruments = np.array(list(devsetups.keys())) if pargs.instrument is None \
                        else np.array([pargs.instrument])
        if pargs.tests == 'afterburn':
            # Only do the flux-calibration and coadding tests
            flg_after = True
        elif pargs.tests == 'ql':
            flg_ql = True
    else:
        instruments = np.array([item for item in all_instruments 
                                    if pargs.tests.lower() in item.lower()])
        unsupported = [item for item in instruments 
                            if not np.any([inst.lower() in item.lower()
                                for inst in supported_instruments()]) ]

    # Check that instruments is not blank
    if len(instruments) == 0:
        print("\x1B[" + "1;31m" + "\nERROR - " + "\x1B[" + "0m" +
              "Invalid test selected: {0:s}\n\n".format(pargs.tests) +
              "Consult the help (pypeit_test -h) or select one of the " +
              "available RAW_DATA directories: {0}".format(', '.join(all_instruments)))
        return 1

    if len(unsupported) > 0:
        print("\x1B[" + "1;33m" + "\nWARNING - " + "\x1B[" + "0m" +
              "The following tests have not been validated and may not pass: {0}\n\n".format(
              unsupported))

    if not os.path.exists(pargs.outputdir):
        os.mkdir(pargs.outputdir)
    outputdir = os.path.abspath(pargs.outputdir)

    # Do DEIMOS last:
    # TODO: Do we still care? It hasn't been last for a long time...
    if 'keck_deimos' in instruments:
        instruments = np.append(np.delete(instruments, np.argwhere(instruments=='keck_deimos')),
                                ['keck_deimos'])

    # Report
    print('Running tests on the following instruments:')
    for instr in instruments:
        print('    {0}'.format(instr))
    print('')

    if pargs.threads > 1:
        print(f'Running tests in {pargs.threads} parallel processes')

    #---------------------------------------------------------------------------
    # Check all the data and relevant files exists before starting!
    # TODO: Do this for "all", as well?
    if pargs.tests in tests_that_only_use_dev_setups:
        unsupported = []
        missing_data = []
        missing_pypfiles = []
        for instr in instruments:
            # Only do blue instruments
            if pargs.debug and 'blue' not in instr:
                continue
            if instr not in devsetups.keys():
                # TODO: We should never get here, right?
                unsupported += [ instr ]

            # Setups
            setups = next(os.walk(os.path.join(raw_data, instr)))[1]

            # Check all data before starting
            for setup in devsetups[instr]:
                if setup not in setups:
                    missing_data += [ '{0}/{1}'.format(instr, setup) ]

                if instr == 'shane_kast_blue' and '600' in setup:
                    # pypeit file is created by pypeit_setup
                    continue

                pyp_file = template_pypeit_file(dev_path, instr, setup)
                if not os.path.isfile(pyp_file):
                    missing_pypfiles += [pyp_file]

        if len(unsupported) > 0:
            raise ValueError('Unsupported instruments: {0}'.format(', '.join(unsupported)))
        if len(missing_data) > 0:
            raise ValueError('Missing the following test data: {0}'.format(
                                ', '.join(missing_data)))
        if len(missing_pypfiles) > 0:
            raise ValueError('Missing the following template pypeit files:\n    {0}'.format(
                                '\n    '.join(missing_pypfiles)))
    #---------------------------------------------------------------------------

    #---------------------------------------------------------------------------
    # Loop on instruments
    npass = 0
    ntest = 0
    
    failed = []

    for instr in instruments:
        # Only do blue instruments
        if pargs.debug and 'blue' not in instr:
            continue

        # Setups
        setups = next(os.walk(os.path.join(raw_data, instr)))[1]
        if pargs.setup is not None and pargs.setup not in setups:
            # No setups selected
            continue
        # Limit to a single setup
        if pargs.setup is not None:
            setups = [ pargs.setup ]
        # Limit to development setups
        if pargs.tests in tests_that_only_use_dev_setups:
            setups = devsetups[instr]

        # Report
        print('Reducing data from {0} for the following setups:'.format(instr))
        for setup in setups:
            print('    {0}'.format(setup))
        print('')

        # Add tests to the test_run_queue
        for setup in setups:

            test_setup = (pargs, instr, setup, flg_after, flg_ql)
            test_run_queue.put(test_setup)

    # Start threads to run the tests
    for i in range(pargs.threads):
        Thread(target=thread_target, daemon=True).start()

    # Wait for the tests to finish
    test_run_queue.join()

    # Report on the test results
    while not test_result_queue.empty():
        result = test_result_queue.get(timeout=2)
        result.report()
        ntest += 1
        if result.passed:
            npass += 1
        else:
            failed.append(f"{result.types[result.type]}: {result.instr}/{result.setup}")

    if npass == ntest:
        print("\n" + "\x1B[" + "1;32m" +
              "--- PYPEIT DEVELOPMENT SUITE PASSED {0}/{1} TESTS (Masters {2}) ---".format(
                npass, ntest, 'reused' if pargs.masters else 'ignored')
              + "\x1B[" + "0m" + "\r", file=sys.stderr)
    else:
        print("\n" + "\x1B[" + "1;31m" +
              "--- PYPEIT DEVELOPMENT SUITE FAILED {0}/{1} TESTS (Masters {2}) ---".format(
                ntest-npass, ntest, 'reused' if pargs.masters else 'ignored')
              + "\x1B[" + "0m" + "\r", file=sys.stderr)
        print('Failed tests:')
        for fail in failed:
            print('    {0}'.format(fail))


def run_test_setup(test_setup):

    pargs, instr, setup, flg_after, flg_ql = test_setup
    dev_path = os.getenv('PYPEIT_DEV')
    raw_data = raw_data_dir()
    outputdir = os.path.abspath(pargs.outputdir)
    test_results = []
    # Directory with raw data
    rawdir = os.path.join(raw_data, instr, setup)

    # Directory for reduced data
    rdxdir = os.path.join(outputdir, instr, setup)
    if not os.path.exists(rdxdir):
        # Make the directory
        os.makedirs(rdxdir)


    # Begin with optimism
    passed = True

    # TODO: By default search for the appropriate pypeit file
    # and run pypeit_setup if it doesn't exist

    # TODO: Include option that forces the tests to run
    # pypeit_setup

    if instr == 'shane_kast_blue' and '600' in setup:
        # Use pypeit_setup to generate the pypeit file
        result, pyp_file, rdxdir = run_pypeit_setup(rawdir, rdxdir, instr, setup)
        passed = result.passed
        std_pyp_file = None
        test_results.append(result)
    else:
        # Use pre-made PypeIt file
        pyp_file = fix_pypeit_file_directory(dev_path, raw_data, instr, setup, rdxdir)
        # Also try to find and fix pypeit files for
        # spectroscopic standards.  This is a KLUDGE for
        # gemini_gmos
        std_pyp_file = fix_pypeit_file_directory(dev_path, raw_data, instr, setup, rdxdir,
                                                 std=True)

    if not passed:
        return test_results

    # Only want to prep
    if pargs.prep_only:
        return test_results

    pyp_file = os.path.split(pyp_file)[1]
    # Run pypeit
    if passed and not (flg_after or flg_ql):
        result = run_pypeit(rdxdir, instr, setup, pyp_file, pargs.masters)
        passed = result.passed
        test_results.append(result)

    # Run pypeit on any standards, if they exist
    if passed and std_pyp_file is not None and not (flg_after or flg_ql):
        result  = run_pypeit(rdxdir, instr, setup, std_pyp_file, pargs.masters)
        passed = result.passed
        test_results.append(result)

    # Try re-running keck_lris_red setups with masters
    if passed and not (flg_after or flg_ql) and instr == 'keck_lris_red' and not flg_ql:
        result = run_pypeit(rdxdir, instr, setup, pyp_file, True)
        passed = result.passed
        test_results.append(result)

    if pargs.tests == 'reduce':
        # Skip the afterburner tests
        return test_results

    # ----------------------------------------------------------
    # ----------------------------------------------------------
    # SensFunc tests
    # ----------------------------------------------------------
    # UVIS algorithm without .sens file
    if passed and instr == 'shane_kast_blue' and '600' in setup and not flg_ql:
        # TODO: Instead check for file with standard star in the
        # file name?
        std_file = os.path.join(rdxdir, 'Science',
                                'spec1d_b24-Feige66_KASTb_2015May20T041246.960.fits')
        test_results.append(run_sensfunc(rdxdir, instr, setup, std_file))

    # IR algorithm with .sens file
    if passed and instr == 'gemini_gnirs' and setup == '32_SB_SXD' and not flg_ql:
        std_file = os.path.join(rdxdir, 'Science',
                                'spec1d_cN20170331S0206-HIP62745_GNIRS_2017Mar31T083351.681.fits')
        sens_file = os.path.join(dev_path, 'sensfunc_files', 'gemini_gnirs_32_sb_sxd.sens')
        test_results.append(run_sensfunc(rdxdir, instr, setup, std_file, sens_file=sens_file))

    # IR algorithm, multi-slit, without .sens file
    if passed and instr == 'gemini_gmos' and setup == 'GS_HAM_R400_860' and not flg_ql:
        std_file = os.path.join(rdxdir, 'Science',
                                'spec1d_S20181219S0316-GD71_GMOS-S_1864May27T230832.356.fits')
        test_results.append(run_sensfunc(rdxdir, instr, setup, std_file))
    # ----------------------------------------------------------

    # ----------------------------------------------------------
    # ----------------------------------------------------------
    # fluxing/coadd1d/tellfit Pypeit files setup tests
    # ----------------------------------------------------------
    flux_setup_pairs = {'shane_kast_blue': '600_4310_d55',  # long-slit
                        'gemini_gnirs': '32_SB_SXD',  # echelle
                        'gemini_gmos': 'GS_HAM_R400_860'}  # multi-slit
    if passed and any([instr == key and setup == flux_setup_pairs[key]
                       for key in flux_setup_pairs.keys()]) and not flg_ql:
        test_results.append(run_flux_setup(rdxdir, instr, setup))

    # ----------------------------------------------------------

    # ----------------------------------------------------------
    # ----------------------------------------------------------
    # Flux calibration tests
    # ----------------------------------------------------------
    flux_calib_pairs = {'shane_kast_blue': '600_4310_d55',  # long-slit
                        'gemini_gnirs': '32_SB_SXD',  # echelle
                        'gemini_gmos': 'GS_HAM_R400_860'}  # multi-slit
    if passed and any([instr == key and setup == flux_calib_pairs[key]
                       for key in flux_calib_pairs.keys()]) and not flg_ql:
        test_results.append(run_flux_calib(dev_path, rdxdir, instr, setup))

    # TODO: Does a sens file exist for NIRES?
    #            # Sensfunc testing, IR algorithm with .sens file
    #            # JFH TODO add a NIRSPEC dataset with a standard
    #            if passed and instr == 'keck_nires':
    #                ntest += 1
    #                if run_flux_calib(dev_path, rdxdir, instr, setup):
    #                    npass += 1
    #                else:
    #                    failed += [ 'pypeit_flux_spec: {0}/{1}'.format(instr, setup) ]
    # ----------------------------------------------------------

    # ----------------------------------------------------------
    # ----------------------------------------------------------
    # 1D coadding tests
    # ----------------------------------------------------------
    coadd_1d_pairs = {'shane_kast_blue': '600_4310_d55',  # long-slit
                      'gemini_gnirs': '32_SB_SXD',  # echelle
                      'gemini_gmos': 'GS_HAM_R400_860'}  # multi-slit
    if passed and any([instr == key and setup == coadd_1d_pairs[key]
                       for key in coadd_1d_pairs.keys()]) and not flg_ql:
        test_results.append(run_coadd1d(dev_path, rdxdir, instr, setup))
    # ----------------------------------------------------------

    # ----------------------------------------------------------
    # ----------------------------------------------------------
    # 2D coadding tests
    # ----------------------------------------------------------
    # Echelle
    if passed and instr == 'gemini_gnirs' and setup == '32_SB_SXD' and not flg_ql:
        test_results.append(run_coadd2d(rdxdir, instr, setup, obj='pisco'))

    # MultiSlit
    if passed and instr == 'keck_lris_blue' and setup == 'multi_600_4000_d560' and not flg_ql:
        test_results.append(run_coadd2d(rdxdir, instr, setup,
                                        coadd_file=template_coadd2d_file(dev_path, instr, setup)))
    # ----------------------------------------------------------

    # ----------------------------------------------------------
    # ----------------------------------------------------------
    # Telluric tests
    # ----------------------------------------------------------
    # Echelle
    if passed and instr == 'gemini_gnirs' and setup == '32_SB_SXD' and not flg_ql:
        test_results.append(run_tellfit(rdxdir, instr, setup, coadd_file='pisco_coadd.fits', redshift=7.52, objmodel='qso'))

    # MultiSlit
    # ToDo: Add a multislit test.

    # ----------------------------------------------------------
    # ----------------------------------------------------------
    # Quick-look tests
    # ----------------------------------------------------------
    # MOS
    if instr == 'shane_kast_blue' and '600' in setup:
        test_results.append(run_ql(rawdir, rdxdir, instr, setup,
                                   ['b1.fits.gz', 'b10.fits.gz', 'b27.fits.gz'], mos=True))

    # NIRES
    if instr.lower() == 'keck_nires' and setup == 'NIRES':
        test_results.append(run_ql(rawdir, rdxdir, instr, setup,
                                   ['s190519_0067.fits', 's190519_0068.fits']))
    # ----------------------------------------------------------

    return test_results

if __name__ == '__main__':
    # Check for pypeit executable
    if not any([os.access(os.path.join(path, 'run_pypeit'), os.X_OK)
                for path in os.environ["PATH"].split(os.pathsep)]):
        raise RuntimeError("You need to install run_pypeit in your PATH")

    # Check for PYPEIT_DEV
    if 'PYPEIT_DEV' not in os.environ:
        raise EnvironmentError('Enviroment must include PYPEIT_DEV, which points to the '
                               'top-level directory with the dev-suite raw data.')

    # Giddy up
    main()


