#!/usr/bin/env python3
#
# See top-level LICENSE.rst file for Copyright information
#
# -*- coding: utf-8 -*-

"""
This script runs the PypeIt development suite of tests
"""

import sys
import os

import numpy as np
from IPython import embed

def develop_setups():
    """
    Return the list of development setups.
    """
    return {'keck_deimos': ['600ZD_M_6500', '1200G_M_7750', '830G_LVM_8400', '830G_M_8100_26',
                            '830G_M_8500', '830G_L_8100'],
            'gemini_gnirs': ['32_SB_SXD'],
            'shane_kast_blue': ['452_3306_d57', '600_4310_d55'],
            'shane_kast_red': ['600_7500_d55_ret', '600_7500_d57'],
            'keck_nires': ['NIRES'],
            'keck_nirspec': ['LOW_NIRSPEC-1'],
            'keck_mosfire': ['Y_long'],
            'magellan_mage': ['1x1'],
            'keck_lris_blue': ['multi_600_4000_d560', 'long_400_3400_d560', 'long_600_4000_d560',
                               'multi_300_5000_d680'],
            'keck_lris_red': ['long_600_7500_d560', 'multi_1200_9000_d680_1x2',
                              'multi_600_5000_d560', 'multi_1200_9000_d680',
                              'multi_400_8500_d560'],
            'vlt_xshooter': ['VIS_1x1', 'VIS_2x1', 'VIS_2x2', 'NIR'],
            'magellan_mage': ['1x1'],
            'gemini_gmos': ['GS_HAM_R400_700']}


def parser(options=None):
    import argparse

    all_tests = ['kast', 'lris', 'deimos', 'nires',  # Instruments
                 'keck', 'magellan', 'vlt', 'gemini'] # Observatories
#    all_tests = ['kast', 'lris', 'isis', 'hires', 'deimos',  # Instruments
#                 'keck', 'shane', 'wht']  # Observatories

    hlpstr = ", ".join(all_tests)

    parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    parser.add_argument('tests', type=str, default=None,
                        help='Tests to run.  Options include: develop, afterburn, all, '
                             '{0:s}'.format(hlpstr))
    parser.add_argument('-o', '--outputdir', type=str,
                        help="Output folder.  Default is ./REDUX_OUT")
    parser.add_argument('--instrument', type=str, help="Restrict to input instrument")
    parser.add_argument('-s', '--setup', type=str, help="Single out a setup to run")
    parser.add_argument('--debug', default=False, action='store_true',
                        help='Debug using only blue setups')
    parser.add_argument('--prep_only', default=False, action='store_true',
                        help='Only prepare to execute run_pypeit, but do not actually run it.')
    parser.add_argument('-m', '--masters', default=False, action='store_true',
                        help='run pypeit using any existing masters')

    # TODO: why are we returning hlpstr?
    return parser.parse_args() if options is None else parser.parse_args(options), hlpstr


def main():
    import glob
    import subprocess
    import warnings

    pargs, hlpstr = parser()

    # TODO: Once we're satisfied that an instrument passes, add it to
    # this list and add a series of setups to the development set!  Runs
    # of PypeIt must pass for all setups in the development list.  See
    # `develop_setups`.
    valid_instruments = ['kast', 'deimos', 'lris', 'nires', 'nirspec', 'gnirs', 'xshooter',
                         'mage', 'mosfire', 'gmos']

    # Grab a list of all instruments
    dev_path = os.getenv('PYPEIT_DEV')
    raw_data = os.path.join(dev_path, 'RAW_DATA')

    if not os.path.isdir(raw_data):
        raise NotADirectoryError('No directory: {0}'.format(raw_data))

    walk = os.walk(raw_data)
    all_instruments = next(walk)[1]
    flg_after = False

    # Development instruments (in returned dictonary keys) and setups
    devsetups = develop_setups()

    # Setup
    if pargs.tests == 'all':
        instruments = [item for item in all_instruments for inst in valid_instruments 
                            if inst.lower() in item.lower()]
        invalid_selection = []
    elif pargs.tests in ['develop', 'afterburn']:
        invalid_selection = []
        if pargs.instrument is not None:
            instruments = [pargs.instrument]
        else:
            instruments = list(devsetups.keys())
        if pargs.tests == 'afterburn':   # Fluxing, COADD2D only
            flg_after = True
    else:
        instruments = [item for item in all_instruments if pargs.tests.lower() in item.lower()]
        invalid_selection = [item for item in instruments if not np.any([inst.lower()
                                    in item.lower() for inst in valid_instruments]) ]

    # Check that instruments is not blank
    if len(instruments) == 0:
        print("\x1B[" + "1;31m" + "\nERROR - " + "\x1B[" + "0m" +
              "Invalid test selected: {0:s}\n\n".format(pargs.tests) +
              "Consult the help (pypeit_test -h) or select one of the " +
              "available RAW_DATA directories: {0}".format(all_instruments))
        return 1

    if len(invalid_selection) > 0:
        print("\x1B[" + "1;33m" + "\nWARNING - " + "\x1B[" + "0m" +
              "The following tests have not been validated and may not pass: {0}\n\n".format(
              invalid_selection))

    outputdir = 'REDUX_OUT' if pargs.outputdir is None else pargs.outputdir
    if not os.path.exists(outputdir):
        os.mkdir(outputdir)
    outputdir = os.path.abspath(outputdir)

    # Loop on instruments
    npass, ntest = 0, 0

    # Do them in order Shane, LRIS, DEIMOS, since DEIMOS takes the
    # longest. To do this we sort and reverse, and then apply the kludge below
    instruments.sort(reverse=True)
    if 'keck_deimos' in instruments and len(instruments) > 2:
        instruments[-2], instruments[-1]=instruments[-1],instruments[-2]

    # Report
    print('Running tests on the following instruments:')
    for instr in instruments:
        print('    {0}'.format(instr))
    print('')

    for instr in instruments:
        # Setups
        print('Instrument: ', instr)
        setups = next(os.walk(os.path.join(raw_data, instr)))[1]
        # Cut me down
        if pargs.debug and 'blue' not in instr:
            continue

        # Develop cut
        if pargs.tests in ['develop', 'afterburn']:
            if instr not in devsetups.keys():
                print('Unknown develop instrument')
                embed(header='163 of pypeit_test')

            # Check me now
            for setup in devsetups[instr]:
                if setup not in setups:
                    print('You need to download the {0} setup '.format(setup)
                          + 'for the {0} instrument before proceeding'.format(instr))
                    embed(header='169 of pypeit_test')

            setups = devsetups[instr]

        # Report
        print('The following setups have been found for {0}:'.format(instr))
        for setup in setups:
            print('    {0}'.format(setup))
        print('')

        for setup in setups:

            if pargs.setup is not None and setup != pargs.setup:
                print('Setup {0} not selected for testing.   Continuing...'.format(setup))
                print('')
                continue

            # Generate folder as need be
            idir = os.path.join(outputdir, instr)
            if not os.path.exists(idir):
                os.makedirs(idir)
            wdir = os.path.join(idir, setup)
            if not os.path.exists(wdir):
                os.makedirs(wdir)

            # rawdata
            rawdir = os.path.join(raw_data, instr, setup)

            # Report
            print('Directories:')
            print('         Raw data: {0}'.format(rawdir))
            print('    PypeIt output: {0}'.format(wdir))
            print('')

            # Run setup?
            passed = True

            # TODO: By default search for the appropriate pypeit file
            # and run pypeit_setup if it doesn't exist
            
            # TODO: Include option that forces the tests to run
            # pypeit_setup

            outfile_root = instr.lower()+'_'+setup.lower()

            if (instr.lower() in ['shane_kast_blue']) and ('600' in setup):
                # Use pypeit_setup to get the pypeit file for Shane Kast Blue
                ntest += 1
                logfile = os.path.join(wdir, outfile_root+'.test.log')
                with open(logfile, 'w') as f:
                    command_line = ['pypeit_setup', '-r', rawdir, '-s', instr.lower(), '-c all',
                                    '-o', '--output_path', wdir ]
                    print('Running command: {0}'.format(' '.join(command_line)))
                    retval = subprocess.call(command_line, stderr=f, cwd=wdir)

                wdir = os.path.join(wdir, instr.lower()+'_A')
                print('Finished running pypeit on {0} --- '.format(outfile_root),
                      file=sys.stderr, end='')

                # Run pypeit on _A.pypeit
                pyp_file = glob.glob(os.path.join(wdir, '*_A.pypeit'))
                if len(pyp_file) != 1:
                    print('Could not find expected pypeit file: {0}'.format(pyp_file))
                    print("\x1B[" + "1;31m" + "FAILED" + "\x1B[" + "0m", file=sys.stderr)
                    passed = False
                else:
                    pyp_file = os.path.split(pyp_file[0])[1]
                    if retval == 0:
                        print("\x1B[" + "1;32m" + "PASSED" + "\x1B[" + "0m", file=sys.stderr)
                        npass += 1
                subprocess.call(['tail', '-2', logfile])
                print("\n", file=sys.stderr)
            else:
                # Use pre-made PypeIt file
                pyp_file = os.path.join('pypeit_files', outfile_root+'.pypeit')

                if not os.path.exists(pyp_file):
                    warnings.warn('PypeIt file {0} does not exist.  Continuing...'.format(pyp_file))
                    continue

                # Read the pypeit file
                with open(pyp_file, 'r') as infile:
                    lines = infile.readlines()

                # Replace the default path with the local one
                for kk, iline in enumerate(lines):
                    if 'data read' in iline:
                        dpth = lines[kk+1]
                        newdpth = ' path ' if 'path' in dpth else ' '
                        i0 = dpth.rfind('/')
                        if setup.strip('/') == dpth[i0:].strip('/\n'):
                            # TODO: Test is for WHT path issue...
                            newdpth += os.path.join(raw_data, instr, setup)+'\n'
                        else:
                            newdpth += os.path.join(raw_data, instr, setup+dpth[i0:])
                        lines[kk+1] = newdpth
                    elif 'flatfield' in iline and 'frame' in lines[kk+1]:
                        newcpth = os.path.join(dev_path, 'CALIBS', os.path.split(lines[kk+1])[1])
                        lines[kk+1] = '        frame = {0}'.format(newcpth)

                # Write to outputdir
                pyp_file = outfile_root+'.pypeit'
                with open(os.path.join(wdir, pyp_file), 'w') as ofile:
                    ofile.writelines(lines)

            if pargs.prep_only:
                continue

            # Run pypeit
            retval = -1
            if passed and (not flg_after):
                ntest += 1
                logfile = os.path.join(wdir, outfile_root+'.test.log')
                print('Running pypeit on {:s} --- '.format(pyp_file), file=sys.stderr, end='')
                with open(logfile, 'w') as f:
                    print('Directory: {0}'.format(wdir))
                    command_line = [ 'run_pypeit', pyp_file, '-o' ]
                    if pargs.masters:
                        command_line += ['-m']
                    print('Command line: {0}'.format(' '.join(command_line)))
                    retval = subprocess.call(command_line, stderr=f, cwd=wdir)
                    npass = report_test(retval, npass)
                    subprocess.call(['tail', '-2', logfile])
                    print("\n", file=sys.stderr)

                # Test master frame running
                if instr in ['keck_lris_red']:
                    ntest += 1
                    print('Running pypeit with master frames on {0} --- '.format(pyp_file),
                          file=sys.stderr, end='')
                    with open(logfile, 'w') as f:
                        print('Directory: {0}'.format(wdir))
                        command_line = [ 'run_pypeit', pyp_file, '-m', '-o' ]
                        print('Command line: {0}'.format(' '.join(command_line)))
                        retval = subprocess.call(command_line, stderr=f, cwd=wdir)
                        npass = report_test(retval, npass)
                        subprocess.call(['tail', '-2', logfile])
                        print("\n", file=sys.stderr)
            elif flg_after:
                retval = 0
            else:
                print("Couldn't run test for {0:s}".format(instr.lower()))

            # Fluxing
            if (retval == 0) and (
                    ((instr.lower() == 'shane_kast_blue') and ('600' in setup)) or
                    (instr.lower() == 'keck_nires')):
                ntest += 1
                print('Running pypeit_flux on {:s} --- '.format(pyp_file), file=sys.stderr, end='')
                logfile = os.path.join(wdir, outfile_root+'.test_flux.log')
                flux_file = os.path.join(dev_path, 'fluxing_files', instr.lower()+'.flux')
                fdir = os.path.join(wdir, 'Science')
                with open(logfile, 'w') as f:
                    print('Directory: {0}'.format(fdir))
                    command_line = [ 'pypeit_flux_spec', flux_file ]
                    print('Command line: {0}'.format(' '.join(command_line)))
                    fretval = subprocess.call(command_line, stderr=f, cwd=fdir)
                    npass = report_test(fretval, npass, type='FLUXING')
                    subprocess.call(['tail', '-3', logfile])
                    print("\n", file=sys.stderr)

            # 2-D coadds Echelle
            if (retval == 0) and (instr.lower() in ['gemini_gnirs']):
                ntest += 1
                print('Running pypeit_coadd_2dspec on {:s} --- '.format(pyp_file),
                      file=sys.stderr, end='')
                logfile = os.path.join(wdir, outfile_root+'.test_2dcoadd.log')
                with open(logfile, 'w') as f:
                    print('Directory: {0}'.format(wdir))
                    command_line = ['pypeit_coadd_2dspec', '--obj', 'pisco']
                    print('Command line: {0}'.format(' '.join(command_line)))
                    cretval = subprocess.call(command_line, stderr=f, cwd=wdir)
                    npass = report_test(cretval, npass, type='COADD2D')
                    subprocess.call(['tail', '-3', logfile])
                    print("\n", file=sys.stderr)

            # 2-D coadds MultiSlit
            if retval == 0 and instr.lower() in ['keck_lris_blue'] \
                    and 'multi_600_4000_d560' in setup:
                ntest += 1
                print('Running pypeit_coadd_2dspec on {:s} --- '.format(pyp_file),
                      file=sys.stderr, end='')
                logfile = os.path.join(wdir, outfile_root+'.test_coadd2d.log')
                coadd2d_file = os.path.join(dev_path, 'coadd2d_files',
                                            instr.lower() + '_' + setup + '.coadd2d')
                with open(logfile, 'w') as f:
                    print('Directory: {0}'.format(wdir))
                    command_line = ['pypeit_coadd_2dspec', '--file', coadd2d_file]
                    print('Command line: {0}'.format(' '.join(command_line)))
                    cretval = subprocess.call(command_line, stderr=f, cwd=wdir)
                    npass = report_test(cretval, npass, type='COADD2D')
                    subprocess.call(['tail', '-3', logfile])
                    print("\n", file=sys.stderr)

            # Quick Look
            if instr.lower() == 'shane_kast_blue' and '600' in setup:
                ntest += 1
                print('Running pypeit_ql_mos on {:s}'.format(instr), file=sys.stderr, end='')
                qldir = os.path.join(wdir,'QL')
                # Generate
                if not os.path.isdir(qldir):
                    os.mkdir(qldir)
                logfile = os.path.join(qldir, outfile_root+'.test_ql.log')
                with open(logfile, 'w') as f:
                    print('Directory: {0}'.format(qldir))
                    command_line = ['pypeit_ql_mos', 'shane_kast_blue',
                                    os.path.join(raw_data, 'shane_kast_blue', '600_4310_d55'),
                                    'b1.fits.gz', 'b10.fits.gz', 'b27.fits.gz']
                    print('Command line: {0}'.format(' '.join(command_line)))
                    cretval = subprocess.call(command_line, stderr=f, cwd=qldir)
                    npass = report_test(cretval, npass, type='QL')
                    subprocess.call(['tail', '-3', logfile])
                    print("\n", file=sys.stderr)

            # Quick Look
            if instr.lower() == 'keck_nires' and setup == 'NIRES':
                ntest += 1
                print('Running pypeit_ql_keck_nires on {:s}'.format(instr), file=sys.stderr,
                      end='')
                qldir = os.path.join(wdir,'QL')
                # Generate
                if not os.path.isdir(qldir):
                    os.mkdir(qldir)
                logfile = os.path.join(qldir, outfile_root+'.test_ql.log')
                with open(logfile, 'w') as f:
                    print('Directory: {0}'.format(qldir))
                    command_line = ['pypeit_ql_keck_nires', os.path.join(
                        raw_data, 'keck_nires', 'NIRES'), 's180604_0089.fits.gz', 's180604_0090.fits.gz']
                    print('Command line: {0}'.format(' '.join(command_line)))
                    cretval = subprocess.call(command_line, stderr=f, cwd=qldir)
                    npass = report_test(cretval, npass, type='QL')
                    subprocess.call(['tail', '-3', logfile])
                    print("\n", file=sys.stderr)

    if npass == ntest:
        print("\n" + "\x1B[" + "1;32m" +
              "--- PYPEIT DEVELOPMENT SUITE PASSED {0:d}/{1:d} TESTS ---".format(npass, ntest) +
              "\x1B[" + "0m" + "\r", file=sys.stderr)
    else:
        print("\n" + "\x1B[" + "1;31m" +
              "--- PYPEIT DEVELOPMENT SUITE FAILED {0:d}/{1:d} TESTS ---".format(ntest-npass,
              ntest) + "\x1B[" + "0m" + "\r", file=sys.stderr)

def report_test(retval, npass, type=None):
    if type is not None:
        fstr = type +  ' '
    else:
        fstr = ''


    if retval == 0:
        print("\x1B[" + "1;32m" + "{}PASSED".format(fstr) + "\x1B[" + "0m", file=sys.stderr)
        return npass + 1
    else:
        print("\x1B[" + "1;31m" + "{}FAILED".format(fstr) + "\x1B[" + "0m", file=sys.stderr)
        return npass

if __name__ == '__main__':
    # Check for pypeit executable
    if not any([os.access(os.path.join(path, 'run_pypeit'), os.X_OK)
                for path in os.environ["PATH"].split(os.pathsep)]):
        raise RuntimeError("You need to install run_pypeit in your PATH")
    # Giddy up
    main()


